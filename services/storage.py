import logging
import uuid
from typing import Dict, List, Optional
from datetime import datetime # For type hinting and default values

try:
    from data_models.schemas import Incident, ReportCoreData
except ImportError as e:
    print(f"ERROR in services.storage: Failed to import Incident/ReportCoreData from data_models.schemas: {e}")
    # Define dummy classes if import fails, to allow other parts of app to load and show error
    class Incident: pass 
    class ReportCoreData: pass
    # raise SystemExit(f"Storage service failed to import schemas: {e}") from e

logger = logging.getLogger(__name__)

class IncidentStore:
    """
    In-memory storage for consolidated Incident objects.
    Uses a dictionary with incident_id as the key. Non-persistent.
    """
    def __init__(self):
        self.incidents: Dict[str, Incident] = {}
        logger.info("In-memory IncidentStore initialized.")

    def create_new_incident_from_core_data(self, core_data: ReportCoreData, summary: str, recommendations: List[str]) -> Optional[Incident]:
        """
        Deprecated: Incident creation should happen in the agent, then saved.
        This method might be removed or refactored if agent always creates Incidents.
        For now, let's assume the agent might pass core_data for a new incident.
        """
        logger.warning("DEPRECATED CALL: IncidentStore.create_new_incident_from_core_data. Incident creation should be handled by the agent.")
        try:
            new_incident = Incident(
                # incident_id is auto-generated by Pydantic default_factory
                incident_type=core_data.incident_type,
                summary=summary,
                recommended_actions=recommendations,
                status="Active", # Initial status
                created_at=core_data.timestamp, # Set created_at from the first report
                last_updated_at=core_data.timestamp # And last_updated_at
            )
            new_incident.add_report_core_data(core_data, match_info="Initial report for new incident")
            self.incidents[new_incident.incident_id] = new_incident
            logger.info(f"Created and stored new Incident {new_incident.incident_id[:8]} from Report {core_data.report_id[:8]}.")
            return new_incident
        except Exception as e:
            logger.error(f"Error in deprecated create_new_incident_from_core_data for report {core_data.report_id[:8]}: {e}", exc_info=True)
            return None


    def save_incident(self, incident: Incident):
        """Saves or updates an incident object in the store."""
        if not isinstance(incident, Incident):
            logger.error(f"Attempted to save non-Incident object: {type(incident)}")
            return
        if not incident.incident_id:
             logger.error("Attempted to save an incident without an incident_id!")
             return

        is_update = incident.incident_id in self.incidents
        # Ensure last_updated_at is set or updated if not already
        if not incident.last_updated_at:
             incident.last_updated_at = datetime.now(tz=datetime.timezone.utc)
        
        self.incidents[incident.incident_id] = incident
        action = "Updated" if is_update else "Saved (new)"
        logger.debug(f"{action} Incident {incident.incident_id[:8]} in store. Total incidents: {len(self.incidents)}")

    def get_incident(self, incident_id: str) -> Optional[Incident]:
        incident = self.incidents.get(incident_id)
        # if incident: logger.debug(f"Retrieved Incident {incident_id[:8]} from store.")
        # else: logger.warning(f"Incident ID {incident_id} not found in store.")
        return incident

    def get_all_incidents(self) -> List[Incident]:
         all_incs = list(self.incidents.values())
         # logger.debug(f"Retrieved all {len(all_incs)} incidents from store.")
         return all_incs

    def get_active_incidents(self) -> List[Incident]:
          active_statuses = ["active", "updated", "received", "rcvd", "dispatched", "dsp", "acknowledged", "ack", "enroute", "enr", "onscene", "onscn", "monitoring"]
          active_incs = [inc for inc in self.incidents.values() if inc.status and inc.status.lower() in active_statuses]
          # logger.debug(f"Found {len(active_incs)} active incidents out of {len(self.incidents)} total.")
          return active_incs
    
    def update_incident_status(self, incident_id: str, new_status: str) -> bool:
        """Updates the status of a specific incident."""
        incident = self.get_incident(incident_id)
        if incident:
            incident.status = new_status
            incident.last_updated_at = datetime.now(tz=datetime.timezone.utc) # Also update timestamp
            self.save_incident(incident) # Re-save to store the change
            logger.info(f"Incident {incident_id[:8]} status updated to '{new_status}'.")
            return True
        logger.warning(f"Cannot update status for non-existent incident ID: {incident_id}")
        return False

    def clear_store(self):
          count = len(self.incidents)
          self.incidents.clear()
          logger.warning(f"Cleared {count} incidents from the store. Store is now empty.")

incident_store = IncidentStore()